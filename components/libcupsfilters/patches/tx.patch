Changes implement the Trusted Extension functionality in cups-filters. Banner
pages on the labeled system are going to be produced by custom labeltops filter
generating a Postscript. Labels on the document are generated by customized
pdftopdf filter.

This patch together with tx.patch in cups and cups-filters makes the
Trusted Extension implementation complete.

--- a/Makefile.am
+++ b/Makefile.am
@@ -173,6 +173,7 @@
 	cupsfilters/imagetopdf.c \
 	cupsfilters/imagetoraster.c \
 	cupsfilters/ipp.c \
+	cupsfilters/labeltops.c \
 	cupsfilters/libcups2.c \
 	cupsfilters/libcups2-private.h \
 	cupsfilters/lut.c \
--- a/cupsfilters/filter.h
+++ b/cupsfilters/filter.h
@@ -314,6 +314,13 @@
 // this filter function.
 
 
+extern int cfFilterLabelToPS(int inputfd,
+			     int outputfd,
+			     int inputseekable,
+			     cf_filter_data_t *data,
+			     void *parameters);
+
+
 extern int cfFilterMuPDFToPWG(int inputfd,
 			      int outputfd,
 			      int inputseekable,
--- a/cupsfilters/universal.c
+++ b/cupsfilters/universal.c
@@ -237,6 +237,31 @@
       if (log) log(ld, CF_LOGLEVEL_DEBUG,
 		   "cfFilterUniversal: Adding %s to chain", filter->name);
     }
+#ifdef HAVE_GHOSTSCRIPT
+    else if (!strcasecmp(input, "application/vnd.cups-labeled-banner"))
+    {
+      filter = malloc(sizeof(cf_filter_filter_in_chain_t));
+      filter->function = cfFilterLabelToPS;
+      filter->parameters =
+	(universal_parameters &&
+	 universal_parameters->bannertopdf_template_dir ?
+	 strdup(universal_parameters->bannertopdf_template_dir) : NULL);
+      filter->name = "labeltops";
+      cupsArrayAdd(filter_chain, filter);
+      if (log) log(ld, CF_LOGLEVEL_DEBUG,
+		   "cfFilterUniversal: Adding %s to chain", filter->name);
+
+      outformat = malloc(sizeof(cf_filter_out_format_t));
+      *outformat = CF_FILTER_OUT_FORMAT_PDF;
+      filter = malloc(sizeof(cf_filter_filter_in_chain_t));
+      filter->function = cfFilterGhostscript;
+      filter->parameters = outformat;
+      filter->name = "ghostscript";
+      cupsArrayAdd(filter_chain, filter);
+      if (log) log(ld, CF_LOGLEVEL_DEBUG,
+		   "cfFilterUniversal: Adding %s to chain", filter->name);
+    }
+#endif // HAVE_GHOSTSCRIPT
     else if (!strcasestr(input_type, "pdf"))
     {
       // Input format is not PDF and unknown -> Error
--- a/cupsfilters/pdftopdf/pdftopdf-processor-private.h
+++ b/cupsfilters/pdftopdf/pdftopdf-processor-private.h
@@ -168,6 +170,9 @@
 
   virtual void add_label(const _cfPDFToPDFPageRect &rect,
 			 const std::string label) = 0;
+
+  virtual void add_tx_label(const _cfPDFToPDFPageRect &rect,
+			         const std::string label) = 0;
 };
 
 // TODO: ... error output?
--- a/cupsfilters/pdftopdf/pdftopdf-processor.cxx
+++ b/cupsfilters/pdftopdf/pdftopdf-processor.cxx
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include "cupsfilters/debug-internal.h"
 #include <numeric>
+#include <tsol/label.h>
 
 void
 BookletMode_dump(pdftopdf_booklet_mode_e bkm,
@@ -452,8 +453,14 @@
       // Note: currently "fixed" in add_subpage(...&rect);
       page->add_border_rect(rect, param.border, 1.0 / pgedit.scale);
 
-    if (!param.page_label.empty())
-      page->add_label(param.page, param.page_label);
+    if (!param.page_label.empty()) {
+      if (is_system_labeled()) {
+        std::string content_type = getenv("CONTENT_TYPE");
+        if (content_type != "application/vnd.cups-labeled-banner")
+	  page->add_tx_label(param.page, param.page_label);
+      } else
+	page->add_label(param.page, param.page_label);
+    }
 
     if (param.cropfit)
     {
--- a/cupsfilters/pdftopdf/qpdf-pdftopdf-processor-private.h
+++ b/cupsfilters/pdftopdf/qpdf-pdftopdf-processor-private.h
@@ -21,6 +21,8 @@
   virtual void rotate(pdftopdf_rotation_e rot);
   virtual void add_label(const _cfPDFToPDFPageRect &rect,
 			 const std::string label);
+  virtual void add_tx_label(const _cfPDFToPDFPageRect &rect,
+			    const std::string label);
   virtual pdftopdf_rotation_e crop(const _cfPDFToPDFPageRect &cropRect,
 				   pdftopdf_rotation_e orientation,
 				   pdftopdf_rotation_e param_orientation,
--- a/cupsfilters/pdftopdf/qpdf-pdftopdf-processor.cxx
+++ b/cupsfilters/pdftopdf/qpdf-pdftopdf-processor.cxx
@@ -544,6 +544,102 @@
   page.addPageContents(stm1, true); // before
   page.addPageContents(stm2, false); // after
 }
+
+void
+_cfPDFToPDFQPDFPageHandle::add_tx_label(const _cfPDFToPDFPageRect &_rect,
+				        const std::string label) // {{{
+{
+  DEBUG_assert(is_existing());
+
+  _cfPDFToPDFPageRect rect = ungetRect (_rect, *this, rotation, page);
+
+  DEBUG_assert(rect.left <= rect.right);
+  DEBUG_assert(rect.bottom <= rect.top);
+
+  double margin = 2.25;
+  std::string font_family = "Courier-Bold";
+  double font_height = 12;
+  double char_width = 7.2;
+
+  // TODO: Only add in the font once, not once per page.
+  QPDFObjectHandle font = page.getOwningQPDF()->makeIndirectObject
+    (QPDFObjectHandle::parse(
+      "<<"
+      " /Type /Font"
+      " /Subtype /Type1"
+      " /Name /pagelabel-font"
+      " /BaseFont /" + font_family + // TODO: support UTF-8 labels?
+      ">>"));
+  QPDFObjectHandle resources = page.getKey ("/Resources");
+  QPDFObjectHandle rfont = resources.getKey ("/Font");
+  rfont.replaceKey ("/pagelabel-font", font);
+
+  // Count the text width with Courier-Bold
+  double text_width = label.length() * char_width;
+
+  // Count where centered frame is
+  double page_center = (rect.left + rect.right) / 2.0;
+
+  double frame_width = text_width + 2 * margin;
+  double frame_height = font_height + 2 * margin;
+
+  double frame_x = page_center - frame_width / 2.0;
+  double top_frame_y = rect.top - frame_height;
+  double bottom_frame_y = rect.bottom;
+
+  std::string boxcmd = "q\n";
+
+  // Black filled rectangle (top)
+  boxcmd += "  0 0 0 rg\n";
+  boxcmd += "  " +
+    QUtil::double_to_string(frame_x) + " " +
+    QUtil::double_to_string(top_frame_y) + " " +
+    QUtil::double_to_string(frame_width) + " " +
+    QUtil::double_to_string(frame_height) + " re f\n";
+
+  // Black filled rectangle (bottom)
+  boxcmd += "  " +
+    QUtil::double_to_string(frame_x) + " " +
+    QUtil::double_to_string(bottom_frame_y) + " " +
+    QUtil::double_to_string(frame_width) + " " +
+    QUtil::double_to_string(frame_height) + " re f\n";
+
+  // White text (top)
+  boxcmd += "  1 1 1 rg\n";
+  boxcmd += "  BT\n";
+  boxcmd += "  /pagelabel-font " + QUtil::double_to_string(font_height) + " Tf\n";
+  boxcmd += "  " +
+    QUtil::double_to_string(frame_x + margin) + " " +
+    QUtil::double_to_string(top_frame_y + margin + (frame_height - font_height) / 2) + " Td\n";
+  boxcmd += "  (" + label + ") Tj\n";
+  boxcmd += "  ET\n";
+
+  // White text (bottom)
+  boxcmd += "  BT\n";
+  boxcmd += "  /pagelabel-font " + QUtil::double_to_string(font_height) + " Tf\n";
+  boxcmd += "  " +
+    QUtil::double_to_string(frame_x + margin) + " " +
+    QUtil::double_to_string(bottom_frame_y + margin + (frame_height - font_height) / 2) + " Td\n";
+  boxcmd += "  (" + label + ") Tj\n";
+  boxcmd += "  ET\n";
+
+  boxcmd += "Q\n";
+
+  DEBUG_assert(page.getOwningQPDF()); // existing pages are always indirect
+  static const char *pre = "%pdftopdf q\n"
+    "q\n",
+    *post="%pdftopdf Q\n"
+    "Q\n";
+
+  QPDFObjectHandle stm1 = QPDFObjectHandle::newStream(page.getOwningQPDF(),
+						      std::string(pre)),
+                   stm2 = QPDFObjectHandle::newStream(page.getOwningQPDF(),
+						      std::string(post) +
+						      boxcmd);
+
+  page.addPageContents(stm1, true); // before
+  page.addPageContents(stm2, false); // after
+}
 // }}}
 
 void
