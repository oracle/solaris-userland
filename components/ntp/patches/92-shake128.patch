This patch fixes the unit tests failures for the SHAKE128 digest. The 
upgrade to OpenSSL 3.5.1 introduced a breaking change to the SHAKE128 calling
sequence by adding a length parameter. 
This is NTP community bug 3965 - Avoid SHAKE128 in unit tests after OpenSSL 3.4
incompatible change
https://bugs.ntp.org/show_bug.cgi?id=3965
This patch may be removed after upgrading to a version of NTP with bug
3965 fixed.

--- include/ntp.h
+++ include/ntp.h
@@ -564,12 +564,10 @@ struct pkt {
 #define	LEN_PKT_NOMAC	(12 * sizeof(u_int32))	/* min header length */
 #define	MIN_MAC_LEN	(1 * sizeof(u_int32))	/* crypto_NAK */
 #define	MD5_LENGTH	16
-#define	SHAKE128_LENGTH	16
 #define	CMAC_LENGTH	16
 #define	SHA1_LENGTH	20
 #define	KEY_MAC_LEN	sizeof(u_int32)		/* key ID in MAC */
 #define	MAX_MD5_LEN	(KEY_MAC_LEN + MD5_LENGTH)
-#define	MAX_SHAKE128_LEN (KEY_MAC_LEN + SHAKE128_LENGTH)
 #define	MAX_SHA1_LEN	(KEY_MAC_LEN + SHA1_LENGTH)
 #define	MAX_MAC_LEN	(6 * sizeof(u_int32))	/* any MAC */
 #define	MAX_MDG_LEN	(MAX_MAC_LEN-KEY_MAC_LEN) /* max. digest len */
diff -Nru a/sntp/crypto.c b/sntp/crypto.c
--- sntp/crypto.c	2025-08-08 20:08:27 +0000
+++ sntp/crypto.c	2025-08-08 20:08:27 +0000
@@ -141,6 +141,8 @@
 	}
 	len = compute_mac(dbuf, sizeof(dbuf),  cmp_key->typen, pkt_data,
 			  pkt_len, cmp_key->key_seq, cmp_key->key_len);
+	/* truncate digests to 20 octets for NTP use. */
+	len = min(len, MAX_MDG_LEN);
 	INSIST(len <= dig_sz);
 	memcpy(digest, dbuf, len);
 
@@ -171,14 +173,12 @@
 	len = compute_mac(dbuf, sizeof(dbuf), cmp_key->typen,
 			  pkt_ptr, pkt_len, cmp_key->key_seq,
 			  cmp_key->key_len);
+	/* truncate digests to 20 octets for NTP use. */
+	len = min(len, MAX_MDG_LEN);
 
 	pkt_ptr += pkt_len + sizeof(keyid_t);
 
-	/* isc_tsmemcmp will be better when its easy to link with.  sntp
-	 * is a 1-shot program, so snooping for timing attacks is
-	 * Harder.
-	 */
-	return mac_len == len && !memcmp(dbuf, pkt_ptr, mac_len);
+	return mac_len == len && 0 == isc_tsmemcmp(dbuf, pkt_ptr, mac_len);
 }
 
 static int
diff -Nru a/sntp/tests/crypto.c b/sntp/tests/crypto.c
--- sntp/tests/crypto.c	2025-08-08 20:08:27 +0000
+++ sntp/tests/crypto.c	2025-08-08 20:08:27 +0000
@@ -6,56 +6,23 @@
 #include "crypto.h"
 
 #define CMAC "AES128CMAC"
-
-#define SHA1_LENGTH 20
 #define CMAC_LENGTH 16
 
 
-void test_MakeSHAKE128Mac(void);
+void test_MakeSHA256Mac(void);
 void test_MakeSHA1Mac(void);
 void test_MakeCMac(void);
-void test_VerifySHAKE128(void);
 void test_VerifySHA1(void);
-void test_VerifyCMAC(void);
+void test_VerifySHA256(void);
 void test_VerifyFailure(void);
+void test_VerifyCMAC(void);
 void test_PacketSizeNotMultipleOfFourBytes(void);
 
+/* helper routines */
+void Possibly_Corrupt_VerifySHA256(bool ForceFailure, const char *test_func);
 void VerifyLocalCMAC(struct key *cmac);
 void VerifyOpenSSLCMAC(struct key *cmac);
-
-
-void
-test_MakeSHAKE128Mac(void)
-{
-#ifdef OPENSSL
-
-	const char KEY[] = "SHAKE128 unit test key";
-	const u_char PAYLOAD[] = "packettestdata16";
-	const size_t PAYLOAD_LEN = sizeof(PAYLOAD) - 1;
-	const u_char EXPECTED_DIGEST[] =
-		"\x62\x5A\x8F\xE4\x66\xCB\xF3\xA6"
-		"\x73\x62\x68\x8D\x11\xB8\x42\xBB";
-	u_char actual[sizeof(EXPECTED_DIGEST) - 1];
-	struct key sk;
-
-	sk.next = NULL;
-	sk.key_id = 10;
-	sk.key_len = sizeof(KEY) - 1;
-	memcpy(&sk.key_seq, KEY, min(sizeof(sk.key_seq), sk.key_len));
-	strlcpy(sk.typen, "SHAKE128", sizeof(sk.typen));
-	sk.typei = keytype_from_text(sk.typen, NULL);
-
-	TEST_ASSERT_EQUAL(sizeof(actual),
-			  make_mac(PAYLOAD, PAYLOAD_LEN, &sk, actual,
-				   sizeof(actual)));
-
-	TEST_ASSERT_EQUAL_HEX8_ARRAY(EXPECTED_DIGEST, actual, sizeof(actual));
-#else
-
-	TEST_IGNORE_MESSAGE("OpenSSL not found, skipping...");
-
-#endif	/* OPENSSL */
-}
+void dump_mac(const char *test_func, u_char *pmac, size_t octets);
 
 
 void
@@ -68,7 +35,7 @@
 	const char* EXPECTED_DIGEST =
 		"\x17\xaa\x82\x97\xc7\x17\x13\x6a\x9b\xa9"
 		"\x63\x85\xb4\xce\xbe\x94\xa0\x97\x16\x1d";
-	char actual[SHA1_LENGTH];
+	u_char actual[sizeof(EXPECTED_DIGEST) - 1];
 
 	struct key sha1;
 	sha1.next = NULL;
@@ -78,11 +45,13 @@
 	strlcpy(sha1.typen, "SHA1", sizeof(sha1.typen));
 	sha1.typei = keytype_from_text(sha1.typen, NULL);
 
+	TEST_ASSERT(0 != sha1.typei);
+
 	TEST_ASSERT_EQUAL(SHA1_LENGTH,
 			  make_mac(PKT_DATA, PKT_LEN, &sha1, actual,
 				   SHA1_LENGTH));
 
-	TEST_ASSERT_EQUAL_MEMORY(EXPECTED_DIGEST, actual, SHA1_LENGTH);
+	TEST_ASSERT_EQUAL_MEMORY(EXPECTED_DIGEST, actual, sizeof(actual));
 
 #else
 
@@ -93,6 +62,46 @@
 
 
 void
+test_MakeSHA256Mac(void)
+{
+#ifdef OPENSSL
+
+	const char	KEY[] = "SHA256 unit test key";
+	const u_char	PAYLOAD[] = "packettestdata16";
+	const size_t	PAYLOAD_LEN = sizeof(PAYLOAD) - 1;
+	struct key	sk;
+	const u_char	EXPECTED_DIGEST[] = {
+				0x7c, 0xae, 0x05, 0xbe,
+				0xaf, 0xe2, 0x02, 0xe9,
+				0x64, 0x3c, 0xa9, 0x80,
+				0xce, 0x55, 0x18, 0xb4,
+				0xf9, 0xec, 0xc6, 0x57
+			};
+	u_char		actual[sizeof(EXPECTED_DIGEST)];
+
+	sk.next = NULL;
+	sk.key_id = 10;
+	sk.key_len = sizeof(KEY) - 1;
+	memcpy(&sk.key_seq, KEY, min(sizeof(sk.key_seq), sk.key_len));
+	strlcpy(sk.typen, "SHA256", sizeof(sk.typen));
+	sk.typei = keytype_from_text(sk.typen, NULL);
+
+	TEST_ASSERT(0 != sk.typei);
+
+	TEST_ASSERT_EQUAL(sizeof(actual),
+		make_mac(PAYLOAD, PAYLOAD_LEN, &sk, actual,
+			sizeof(actual)));
+	dump_mac(__func__, actual, sizeof(actual));
+	TEST_ASSERT_EQUAL_HEX8_ARRAY(EXPECTED_DIGEST, actual, sizeof(actual));
+#else
+
+	TEST_IGNORE_MESSAGE("OpenSSL not found, skipping...");
+
+#endif	/* OPENSSL */
+}
+
+
+void
 test_MakeCMac(void)
 {
 #if defined(OPENSSL) && defined(ENABLE_CMAC)
@@ -125,44 +134,6 @@
 
 
 void
-test_VerifySHAKE128(void)
-{
-#ifdef OPENSSL
-	const char KEY[] = "SHAKE128 unit test key";
-	const u_char PAYLOAD[] = "packettestdata16";
-	const size_t PAYLOAD_LEN = sizeof(PAYLOAD) - 1;
-	const u_char EXPECTED_DIGEST[] =
-		"\x62\x5A\x8F\xE4\x66\xCB\xF3\xA6"
-		"\x73\x62\x68\x8D\x11\xB8\x42\xBB";
-	const size_t DIGEST_LEN = sizeof(EXPECTED_DIGEST) - 1;
-	struct key sk;
-	u_char PKT_DATA[  PAYLOAD_LEN + sizeof(sk.key_id)
-			+ DIGEST_LEN];
-	u_char *p;
-
-	sk.next = NULL;
-	sk.key_id = 0;
-	sk.key_len = sizeof(KEY) - 1;
-	memcpy(&sk.key_seq, KEY, min(sizeof(sk.key_seq), sk.key_len));
-	strlcpy(sk.typen, "SHAKE128", sizeof(sk.typen));
-	sk.typei = keytype_from_text(sk.typen, NULL);
-
-	p = PKT_DATA;
-	memcpy(p, PAYLOAD, PAYLOAD_LEN);	  p += PAYLOAD_LEN;
-	memcpy(p, &sk.key_id, sizeof(sk.key_id)); p += sizeof(sk.key_id);
-	memcpy(p, EXPECTED_DIGEST, DIGEST_LEN);	  p += DIGEST_LEN;
-	TEST_ASSERT_TRUE(sizeof(PKT_DATA) == p - PKT_DATA);
-
-	TEST_ASSERT_TRUE(auth_md5(PKT_DATA, PAYLOAD_LEN, DIGEST_LEN, &sk));
-#else
-
-	TEST_IGNORE_MESSAGE("OpenSSL not found, skipping...");
-
-#endif	/* OPENSSL */
-}
-
-
-void
 test_VerifySHA1(void)
 {
 #ifdef OPENSSL
@@ -182,6 +153,8 @@
 	strlcpy(sha1.typen, "SHA1", sizeof(sha1.typen));
 	sha1.typei = keytype_from_text(sha1.typen, NULL);
 
+	TEST_ASSERT(0 != sha1.typei);
+
 	TEST_ASSERT_TRUE(auth_md5(PKT_DATA, PKT_LEN, SHA1_LENGTH, &sha1));
 
 #else
@@ -193,6 +166,75 @@
 
 
 void
+Possibly_Corrupt_VerifySHA256(
+	bool		ForceFailure,
+	const char *	test_func
+	)
+{
+#ifdef OPENSSL
+	const char	KEY[] = "SHA256 unit test key";
+	const u_char	PAYLOAD[] = "packettestdata16";
+	const size_t	PAYLOAD_LEN = sizeof(PAYLOAD) - 1;
+	const u_char	EXPECTED_DIGEST[] = {	/* from test_MakeSHA256Mac */
+				0x7c, 0xae, 0x05, 0xbe,
+				0xaf, 0xe2, 0x02, 0xe9,
+				0x64, 0x3c, 0xa9, 0x80,
+				0xce, 0x55, 0x18, 0xb4,
+				0xf9, 0xec, 0xc6, 0x57
+			};
+	const size_t	DIGEST_LEN = sizeof(EXPECTED_DIGEST);
+	struct key	sk;
+	u_char		PKT_DATA[PAYLOAD_LEN + sizeof(sk.key_id)
+			 + DIGEST_LEN];
+	u_char *	p;
+
+	sk.next = NULL;
+	sk.key_id = 0;
+	sk.key_len = sizeof(KEY) - 1;
+	memcpy(&sk.key_seq, KEY, min(sizeof(sk.key_seq), sk.key_len));
+	strlcpy(sk.typen, "SHA256", sizeof(sk.typen));
+	sk.typei = keytype_from_text(sk.typen, NULL);
+
+	TEST_ASSERT(0 != sk.typei);
+
+	p = PKT_DATA;
+	memcpy(p, PAYLOAD, PAYLOAD_LEN);	  p += PAYLOAD_LEN;
+	memcpy(p, &sk.key_id, sizeof(sk.key_id)); p += sizeof(sk.key_id);
+	memcpy(p, EXPECTED_DIGEST, DIGEST_LEN);
+	if (ForceFailure) {
+		(*p)++;
+	}
+	p += DIGEST_LEN;
+	TEST_ASSERT_TRUE(sizeof(PKT_DATA) == p - PKT_DATA);
+
+	if (!ForceFailure) {
+		TEST_ASSERT_TRUE(auth_md5(PKT_DATA, PAYLOAD_LEN, DIGEST_LEN, &sk));
+	} else {
+		TEST_ASSERT_FALSE(auth_md5(PKT_DATA, PAYLOAD_LEN, DIGEST_LEN, &sk));
+	}
+#else
+
+	TEST_IGNORE_MESSAGE("OpenSSL not found, skipping...");
+
+#endif	/* OPENSSL */
+}
+
+
+void
+test_VerifySHA256(void)
+{
+	Possibly_Corrupt_VerifySHA256(false, __func__);
+}
+
+
+void
+test_VerifyFailure(void)
+{
+	Possibly_Corrupt_VerifySHA256(true, __func__);
+}
+
+
+void
 test_VerifyCMAC(void)
 {
 	struct key cmac;
@@ -240,49 +282,6 @@
 
 
 void
-test_VerifyFailure(void)
-{
-	/*
-	 * We use a copy of test_VerifySHAKE128(), but modify the
-	 * last packet octet to make sure verification fails.
-	 */
-#ifdef OPENSSL
-	const char KEY[] = "SHAKE128 unit test key";
-	const u_char PAYLOAD[] = "packettestdata1_";
-				/* last packet byte different */
-	const size_t PAYLOAD_LEN = sizeof(PAYLOAD) - 1;
-	const u_char EXPECTED_DIGEST[] =
-		"\x62\x5A\x8F\xE4\x66\xCB\xF3\xA6"
-		"\x73\x62\x68\x8D\x11\xB8\x42\xBB";
-	const size_t DIGEST_LEN = sizeof(EXPECTED_DIGEST) - 1;
-	struct key sk;
-	u_char PKT_DATA[  PAYLOAD_LEN + sizeof(sk.key_id)
-			+ DIGEST_LEN];
-	u_char *p;
-
-	sk.next = NULL;
-	sk.key_id = 0;
-	sk.key_len = sizeof(KEY) - 1;
-	memcpy(&sk.key_seq, KEY, min(sizeof(sk.key_seq), sk.key_len));
-	strlcpy(sk.typen, "SHAKE128", sizeof(sk.typen));
-	sk.typei = keytype_from_text(sk.typen, NULL);
-
-	p = PKT_DATA;
-	memcpy(p, PAYLOAD, PAYLOAD_LEN);	  p += PAYLOAD_LEN;
-	memcpy(p, &sk.key_id, sizeof(sk.key_id)); p += sizeof(sk.key_id);
-	memcpy(p, EXPECTED_DIGEST, DIGEST_LEN);	  p += DIGEST_LEN;
-	TEST_ASSERT_TRUE(sizeof(PKT_DATA) == p - PKT_DATA);
-
-	TEST_ASSERT_FALSE(auth_md5(PKT_DATA, PAYLOAD_LEN, DIGEST_LEN, &sk));
-#else
-
-	TEST_IGNORE_MESSAGE("OpenSSL not found, skipping...");
-
-#endif	/* OPENSSL */
-}
-
-
-void
 test_PacketSizeNotMultipleOfFourBytes(void)
 {
 	/*
@@ -307,6 +306,8 @@
 	strlcpy(sk.typen, "SHAKE128", sizeof(sk.typen));
 	sk.typei = keytype_from_text(sk.typen, NULL);
 
+	TEST_ASSERT(0 != sk.typei);
+
 	TEST_ASSERT_EQUAL(0,
 			  make_mac(PAYLOAD, PAYLOAD_LEN, &sk, actual,
 				   sizeof(actual)));
@@ -316,3 +317,48 @@
 
 #endif	/* OPENSSL */
 }
+
+
+/*
+ * Dump a MAC in a form easy to cut and paste into the expected declaration.
+ * This is noisy in the test logs but they're generally examined only when
+ * adding another digest algorithm to the unit tests, where they are very
+ * helpful as the assertion failure messages do not provide the generated
+ * MAC to put into the expected declaration.
+ */
+void dump_mac(
+	const char *	test_func,
+	u_char *	pmac,
+	size_t		octets
+	)
+{
+	char	dump[2048];
+	size_t	dc = 0;
+	size_t	idx;
+
+	dc += snprintf(dump + dc, sizeof(dump) - dc,
+		"\n%s\n"
+		"\tconst u_char EXPECTED_DIGEST[] = {",
+		test_func);
+
+	for (idx = 0; idx < octets; idx++) {
+		if (0 == idx % 4) {
+			dc += snprintf(dump + dc, sizeof(dump) - dc, "\n\t\t\t");
+		}
+		if (dc < sizeof(dump)) {
+			dc += snprintf(dump + dc, sizeof(dump) - dc,
+				"0x%02x, ", pmac[idx]);
+		}
+	}
+
+	/* wipe out final comma and space */
+	if (dc > 2) {
+		dc -= 2;
+	}
+	if (dc < sizeof(dump)) {
+		dc += snprintf(dump + dc, sizeof(dump) - dc, "\n\t\t};");
+	}
+
+	msyslog(LOG_DEBUG, "%s", dump);
+}
+
diff -Nru a/sntp/tests/packetHandling.c b/sntp/tests/packetHandling.c
--- sntp/tests/packetHandling.c	2025-08-08 20:08:27 +0000
+++ sntp/tests/packetHandling.c	2025-08-08 20:08:27 +0000
@@ -14,6 +14,7 @@
 
 void setUp(void);
 int LfpEquality(const l_fp expected, const l_fp actual);
+
 void test_GenerateUnauthenticatedPacket(void);
 void test_GenerateAuthenticatedPacket(void);
 void test_OffsetCalculationPositiveOffset(void);
@@ -25,6 +26,8 @@
 void test_HandleKodRate(void);
 void test_HandleCorrectPacket(void);
 
+void dump_mac(const char *test_func, u_char *pmac, size_t octets);
+
 
 void
 setUp(void)
@@ -74,7 +77,7 @@
 {
 #ifdef OPENSSL
 
-	const int EXPECTED_PKTLEN = LEN_PKT_NOMAC + MAX_SHAKE128_LEN;
+	const int EXPECTED_PKTLEN = LEN_PKT_NOMAC + KEY_MAC_LEN + MAX_MDG_LEN;
 
 	struct key	testkey;
 	struct pkt	testpkt;
@@ -82,18 +85,19 @@
 	l_fp		expected_xmt, actual_xmt;
 	const char key[] = "123456789";
 	size_t		mac_sz;
-	const u_char 	expected_mac[] = {
-				0x46, 0x79, 0x81, 0x6b,
-				0x22, 0xe3, 0xa7, 0xaf,
-				0x1d, 0x63, 0x20, 0xfb,
-				0xc7, 0xd6, 0x87, 0x2c
+	const u_char	expected_mac[] = {
+				0x74, 0x66, 0x61, 0x32,
+				0xfa, 0x44, 0xd7, 0x22,
+				0x97, 0x27, 0xca, 0xac,
+				0x95, 0xd9, 0x13, 0xe2,
+				0x5f, 0xc5, 0x7e, 0x1f
 			};
 
 	testkey.next = NULL;
 	testkey.key_id = 30;
 	strlcpy(testkey.key_seq, key, sizeof(testkey.key_seq));
 	testkey.key_len = strlen(testkey.key_seq);
-	strlcpy(testkey.typen, "SHAKE128", sizeof(testkey.typen));
+	strlcpy(testkey.typen, "SHA256", sizeof(testkey.typen));
 	testkey.typei = keytype_from_text(testkey.typen, NULL);
 
 	xmt.tv_sec = JAN_1970;
@@ -116,13 +120,13 @@
 
 	TEST_ASSERT_EQUAL(testkey.key_id, ntohl(testpkt.exten[0]));
 
-	TEST_ASSERT_EQUAL(sizeof(expected_mac), SHAKE128_LENGTH);
+	TEST_ASSERT_EQUAL(sizeof(expected_mac), MAX_MDG_LEN);
  	mac_sz = make_mac(&testpkt, LEN_PKT_NOMAC, &testkey,
 			  &testpkt.exten[1], MAX_MDG_LEN);
-	TEST_ASSERT_EQUAL(mac_sz, SHAKE128_LENGTH);
-
-	TEST_ASSERT_EQUAL_MEMORY(expected_mac, (void *)&testpkt.exten[1],
-				 SHAKE128_LENGTH);
+	TEST_ASSERT_EQUAL(mac_sz, MAX_MDG_LEN);
+	dump_mac(__func__, (void *)&testpkt.exten[1], mac_sz);
+	TEST_ASSERT_EQUAL_HEX8_ARRAY(expected_mac, (void *)&testpkt.exten[1],
+				     mac_sz);
 
 #else	/* !OPENSSL follows */
 
@@ -331,4 +335,48 @@
 	TEST_ASSERT_EQUAL(0, handle_pkt(rpktl, &rpkt, &host, ""));
 }
 
+
+/*
+ * Dump a MAC in a form easy to cut and paste into the expected declaration.
+ * This is noisy in the test logs but they're generally examined only when
+ * adding another digest algorithm to the unit tests, where they are very
+ * helpful as the assertion failure messages do not provide the generated
+ * MAC to put into the expected declaration.
+ */
+void dump_mac(
+	const char *	test_func,
+	u_char *	pmac,
+	size_t		octets
+)
+{
+	char	dump[2048];
+	size_t	dc = 0;
+	size_t	idx;
+
+	dc += snprintf(dump + dc, sizeof(dump) - dc,
+		"\n%s\n"
+		"\tconst u_char\texpected_mac[] = {",
+		test_func);
+
+	for (idx = 0; idx < octets; idx++) {
+		if (0 == idx % 4) {
+			dc += snprintf(dump + dc, sizeof(dump) - dc, "\n\t\t\t\t");
+		}
+		if (dc < sizeof(dump)) {
+			dc += snprintf(dump + dc, sizeof(dump) - dc,
+				"0x%02x, ", pmac[idx]);
+		}
+	}
+
+	/* wipe out final comma and space */
+	if (dc > 2) {
+		dc -= 2;
+	}
+	if (dc < sizeof(dump)) {
+		dc += snprintf(dump + dc, sizeof(dump) - dc, "\n\t\t\t};");
+	}
+
+	msyslog(LOG_DEBUG, "%s", dump);
+}
+
 /* packetHandling.c */
diff -Nru a/sntp/tests/packetProcessing.c b/sntp/tests/packetProcessing.c
--- sntp/tests/packetProcessing.c	2025-08-08 20:08:27 +0000
+++ sntp/tests/packetProcessing.c	2025-08-08 20:08:27 +0000
@@ -34,7 +34,7 @@
 void test_AcceptNoSentPacketBroadcastMode(void);
 void test_CorrectUnauthenticatedPacket(void);
 void test_CorrectAuthenticatedPacketMD5(void);
-void test_CorrectAuthenticatedPacketSHAKE128(void);
+void test_CorrectAuthenticatedPacketSHA256(void);
 void test_CorrectAuthenticatedPacketSHA1(void);
 void test_CorrectAuthenticatedPacketCMAC(void);
 
@@ -222,7 +222,7 @@
 	size_t mac_len;
 
 	/* Activate authentication option */
-	PrepareAuthenticationTest(50, 9, "SHAKE128", "123456789");
+	PrepareAuthenticationTest(50, 9, "SHA256", "123456789");
 	TEST_ASSERT_TRUE(ENABLED_OPT(AUTHENTICATION));
 
 	/* Prepare the packet. */
@@ -255,7 +255,7 @@
 	size_t mac_len;
 
 	/* Activate authentication option */
-	PrepareAuthenticationTest(30, 9, "SHAKE128", "123456789");
+	PrepareAuthenticationTest(30, 9, "SHA256", "123456789");
 	TEST_ASSERT_TRUE(ENABLED_OPT(AUTHENTICATION));
 
 	/* Prepare the packet. Note that the Key-ID expected is 30, but
@@ -457,7 +457,7 @@
 
 
 void
-test_CorrectAuthenticatedPacketSHAKE128(void)
+test_CorrectAuthenticatedPacketSHA256(void)
 {
 #ifdef OPENSSL
 
@@ -465,13 +465,13 @@
 	int pkt_len = LEN_PKT_NOMAC;
 	int mac_len;
 
-	PrepareAuthenticationTest(k_id, 15, "SHAKE128", "123456789abcdef");
+	PrepareAuthenticationTest(k_id, 15, "SHA256", "123456789abcdef");
 	TEST_ASSERT_TRUE(ENABLED_OPT(AUTHENTICATION));
 
 	/* Prepare the packet. */
 	testpkt.p.exten[0] = htonl(k_id);
 	mac_len = make_mac(&testpkt.p, pkt_len, key_ptr, &testpkt.p.exten[1],
-			   SHAKE128_LENGTH);
+			   MAX_MDG_LEN);
 
 	pkt_len += KEY_MAC_LEN + mac_len;
 
diff -Nru a/sntp/tests/run-crypto.c b/sntp/tests/run-crypto.c
--- sntp/tests/run-crypto.c	2025-08-08 20:08:27 +0000
+++ sntp/tests/run-crypto.c	2025-08-08 20:08:27 +0000
@@ -30,13 +30,13 @@
 //=======External Functions This Runner Calls=====
 extern void setUp(void);
 extern void tearDown(void);
-extern void test_MakeSHAKE128Mac(void);
+extern void test_MakeSHA256Mac(void);
 extern void test_MakeSHA1Mac(void);
 extern void test_MakeCMac(void);
-extern void test_VerifySHAKE128(void);
 extern void test_VerifySHA1(void);
-extern void test_VerifyCMAC(void);
+extern void test_VerifySHA256(void);
 extern void test_VerifyFailure(void);
+extern void test_VerifyCMAC(void);
 extern void test_PacketSizeNotMultipleOfFourBytes(void);
 
 
@@ -66,14 +66,14 @@
   progname = argv[0];
   suite_setup();
   UnityBegin("crypto.c");
-  RUN_TEST(test_MakeSHAKE128Mac, 14);
-  RUN_TEST(test_MakeSHA1Mac, 15);
-  RUN_TEST(test_MakeCMac, 16);
-  RUN_TEST(test_VerifySHAKE128, 17);
-  RUN_TEST(test_VerifySHA1, 18);
-  RUN_TEST(test_VerifyCMAC, 19);
-  RUN_TEST(test_VerifyFailure, 20);
-  RUN_TEST(test_PacketSizeNotMultipleOfFourBytes, 21);
+  RUN_TEST(test_MakeSHA256Mac, 12);
+  RUN_TEST(test_MakeSHA1Mac, 13);
+  RUN_TEST(test_MakeCMac, 14);
+  RUN_TEST(test_VerifySHA1, 15);
+  RUN_TEST(test_VerifySHA256, 16);
+  RUN_TEST(test_VerifyFailure, 17);
+  RUN_TEST(test_VerifyCMAC, 18);
+  RUN_TEST(test_PacketSizeNotMultipleOfFourBytes, 19);
 
   return (UnityEnd());
 }
diff -Nru a/sntp/tests/run-packetHandling.c b/sntp/tests/run-packetHandling.c
--- sntp/tests/run-packetHandling.c	2025-08-08 20:08:27 +0000
+++ sntp/tests/run-packetHandling.c	2025-08-08 20:08:27 +0000
@@ -73,16 +73,16 @@
   progname = argv[0];
   suite_setup();
   UnityBegin("packetHandling.c");
-  RUN_TEST(test_GenerateUnauthenticatedPacket, 17);
-  RUN_TEST(test_GenerateAuthenticatedPacket, 18);
-  RUN_TEST(test_OffsetCalculationPositiveOffset, 19);
-  RUN_TEST(test_OffsetCalculationNegativeOffset, 20);
-  RUN_TEST(test_HandleUnusableServer, 21);
-  RUN_TEST(test_HandleUnusablePacket, 22);
-  RUN_TEST(test_HandleServerAuthenticationFailure, 23);
-  RUN_TEST(test_HandleKodDemobilize, 24);
-  RUN_TEST(test_HandleKodRate, 25);
-  RUN_TEST(test_HandleCorrectPacket, 26);
+  RUN_TEST(test_GenerateUnauthenticatedPacket, 18);
+  RUN_TEST(test_GenerateAuthenticatedPacket, 19);
+  RUN_TEST(test_OffsetCalculationPositiveOffset, 20);
+  RUN_TEST(test_OffsetCalculationNegativeOffset, 21);
+  RUN_TEST(test_HandleUnusableServer, 22);
+  RUN_TEST(test_HandleUnusablePacket, 23);
+  RUN_TEST(test_HandleServerAuthenticationFailure, 24);
+  RUN_TEST(test_HandleKodDemobilize, 25);
+  RUN_TEST(test_HandleKodRate, 26);
+  RUN_TEST(test_HandleCorrectPacket, 27);
 
   return (UnityEnd());
 }
diff -Nru a/sntp/tests/run-packetProcessing.c b/sntp/tests/run-packetProcessing.c
--- sntp/tests/run-packetProcessing.c	2025-08-08 20:08:27 +0000
+++ sntp/tests/run-packetProcessing.c	2025-08-08 20:08:27 +0000
@@ -47,7 +47,7 @@
 extern void test_AcceptNoSentPacketBroadcastMode(void);
 extern void test_CorrectUnauthenticatedPacket(void);
 extern void test_CorrectAuthenticatedPacketMD5(void);
-extern void test_CorrectAuthenticatedPacketSHAKE128(void);
+extern void test_CorrectAuthenticatedPacketSHA256(void);
 extern void test_CorrectAuthenticatedPacketSHA1(void);
 extern void test_CorrectAuthenticatedPacketCMAC(void);
 
@@ -95,7 +95,7 @@
   RUN_TEST(test_AcceptNoSentPacketBroadcastMode, 34);
   RUN_TEST(test_CorrectUnauthenticatedPacket, 35);
   RUN_TEST(test_CorrectAuthenticatedPacketMD5, 36);
-  RUN_TEST(test_CorrectAuthenticatedPacketSHAKE128, 37);
+  RUN_TEST(test_CorrectAuthenticatedPacketSHA256, 37);
   RUN_TEST(test_CorrectAuthenticatedPacketSHA1, 38);
   RUN_TEST(test_CorrectAuthenticatedPacketCMAC, 39);
 
--- tests/libntp/data/ntp.keys
+++ tests/libntp/data/ntp.keys
@@ -11,6 +11,21 @@
 # Each digest is tested twice with keyids separated by 50 for
 # plaintext and hex-encoded keys.
 #
+# OpenSSL 3.4 broke backwards compatibility for SHAKE128 and SHAKE256.
+# These are unusual digests with a configurable output size, and earlier
+# OpenSSL defaults led some to believe the 128 and 256 in their names
+# were the fixed digest size, while in fact they indicate some other
+# parameter and if used with those output sizes, which were used by
+# default in earlier OpenSSL, they are relatively weak compared to
+# other digests with those resulting digest sizes.
+#
+# If we use SHAKE128 or SHAKE256 here, the EVP_DigestFinal() calls
+# will always fail as we have not specified an output size.  Given they
+# are relatively weak with smaller output sizes and we're truncating
+# all digests to 160 bits, we are just avoiding them.  They are not
+# included in ntpq -c "help keytype" output because they fail with our
+# code.
+#
 
  1 AES128CMAC	X~A=%NWlo]p$dGq,S3M9
  2 MD4		oV'8?f+J5`_EOvW!B,R`
@@ -18,7 +33,7 @@
  4 MDC2		b@XOS~6VZ.E9Qv!CJYV,
  5 RIPEMD160	I89p}f6QopwC\LwHBm;e
  6 SHA1		A;H=E;.m4N%t%EeJ90[d
- 7 SHAKE128	|HxLoa,mzG<"y>^TI_(1
+ 7 SHA512	|HxLoa,mzG<"y>^TI_(1
  8 DSA		306+^SHLV5{"v7W`U3aY
  9 DSA-SHA	lGyKZgsI_Pi"y"8JAT98
 10 SHA		2:VO]Q5u%/b&}.<P?T~9
@@ -30,7 +45,7 @@
 54 MDC2		3cb1d4633a460179a7c96aed6c6a9273c3c98af8
 55 RIPEMD160	6028ec169bfbe55ab61ffa7baa34b482020f0619
 56 SHA1		17d96a86eb9b9075f33e1c0a08bb2bb61e916e33
-57 SHAKE128	70da1a91030eb91836c1cf76cf67ddfd6b96fa91
+57 SHA512	af918f855e5a408729a68230cdbc7c74dc9762e46e1fdf884dee2cdfd9072a4d28d9fc5dd8eb
 58 DSA		7ce5deea7569d7423d5e1b497c8eb3bfeff852d5
 59 DSA-SHA	9fd568e8f371deae54a65bc50b52bbe1f6529589
 60 SHA		ce85046978a4df8366e102c4f1267399bbc25737
--- tests/libntp/digests.c
+++ tests/libntp/digests.c
@@ -10,8 +10,8 @@
 #include "ntp_stdlib.h"
 
 /*
- * tests/libntp/data/ntp.keys has two keys for each algorithm, 50 keyids apart.
- * The first is 20 random ASCII chars, the 2nd 40 random hex values.
+ * tests/libntp/data/ntp.keys has 2 keys for each algorithm, 50 keyids apart.
+ * The 1st is 20 random ASCII chars, the 2nd 40 or more random hex characters.
  */
 #define HEX_KEYID_OFFSET	50
 
@@ -104,7 +104,7 @@ do {									\
 									\
 	zero_mem(mac, MAX_MAC_LEN);					\
 	if (!auth_findkey(key)) {					\
-		TEST_IGNORE_MESSAGE("MAC unsupported on this system");	\
+		TEST_IGNORE_MESSAGE("MAC unavailable");	\
 		return;							\
 	}								\
 	authtrust((key), 1);						\
@@ -116,7 +116,7 @@ do {									\
 	}								\
 	TEST_ASSERT_EQUAL_UINT((u_int)((exp_sz) + KEY_MAC_LEN), res_sz);\
 	dump_mac((key), mac, res_sz);					\
-	TEST_ASSERT_EQUAL_HEX8_ARRAY((exp_mac), mac, MAX_MAC_LEN);	\
+	TEST_ASSERT_EQUAL_HEX8_ARRAY((exp_mac), mac, res_sz);	\
 } while (FALSE)
 
 
@@ -131,7 +131,7 @@ void test_Digest_AES128CMAC(void);
 void test_Digest_AES128CMAC(void)
 {
 #if defined(OPENSSL) && defined(ENABLE_CMAC)
-	u_char expectedA[MAX_MAC_LEN] =
+	u_char expectedA[] =
 		{ 
 			0, 0, 0, KEYID_A,
 			0x34, 0x5b, 0xcf, 0xa8,
@@ -139,7 +139,7 @@ void test_Digest_AES128CMAC(void)
 			0xeb, 0x81, 0x25, 0xc2,
 			0xa4, 0xb8, 0x1b, 0xe0
 		};
-	u_char expectedB[MAX_MAC_LEN] =
+	u_char expectedB[] =
 		{
 			0, 0, 0, KEYID_B,
 			0xd1, 0x04, 0x4e, 0xbf,
@@ -168,7 +168,7 @@ void test_Digest_MD4(void);
 void test_Digest_MD4(void)
 {
 #ifdef OPENSSL
-	u_char expectedA[MAX_MAC_LEN] =
+	u_char expectedA[] =
 		{
 			0, 0, 0, KEYID_A,
 			0xf3, 0x39, 0x34, 0xca,
@@ -176,7 +176,7 @@ void test_Digest_MD4(void)
 			0x13, 0xca, 0x56, 0x9e,
 			0xbc, 0x53, 0x9c, 0x66
 		};
-	u_char expectedB[MAX_MAC_LEN] =
+	u_char expectedB[] =
 		{
 			0, 0, 0, KEYID_B,
 			0x5e, 0xe6, 0x81, 0xf2,
@@ -204,7 +204,7 @@ void test_Digest_MD4(void)
 void test_Digest_MD5(void);
 void test_Digest_MD5(void)
 {
-	u_char expectedA[MAX_MAC_LEN] =
+	u_char expectedA[] =
 		{
 			0, 0, 0, KEYID_A,
 			0xa6, 0x8d, 0x3a, 0xfe,
@@ -212,7 +212,7 @@ void test_Digest_MD5(void)
 			0x4c, 0x97, 0x72, 0x16,
 			0x7c, 0x28, 0x18, 0xaf
 		};
-	u_char expectedB[MAX_MAC_LEN] =
+	u_char expectedB[] =
 		{
 			0, 0, 0, KEYID_B,
 			0xd4, 0x11, 0x2c, 0xc6,
@@ -238,7 +238,7 @@ void test_Digest_MDC2(void);
 void test_Digest_MDC2(void)
 {
 #ifdef OPENSSL
-	u_char expectedA[MAX_MAC_LEN] =
+	u_char expectedA[] =
 		{
 			0, 0, 0, KEYID_A,
 			0xa0, 0xfc, 0x18, 0xb6,
@@ -246,7 +246,7 @@ void test_Digest_MDC2(void)
 			0xc9, 0x64, 0x0e, 0x41,
 			0x95, 0x90, 0x5d, 0xf5
 		};
-	u_char expectedB[MAX_MAC_LEN] =
+	u_char expectedB[] =
 		{
 			0, 0, 0, KEYID_B,
 			0xe3, 0x2c, 0x1e, 0x64,
@@ -275,7 +275,7 @@ void test_Digest_RIPEMD160(void);
 void test_Digest_RIPEMD160(void)
 {
 #ifdef OPENSSL
-	u_char expectedA[MAX_MAC_LEN] =
+	u_char expectedA[] =
 		{ 
 			0, 0, 0, KEYID_A,
 			0x8c, 0x3e, 0x55, 0xbb,
@@ -284,7 +284,7 @@ void test_Digest_RIPEMD160(void)
 			0xdd, 0x29, 0x32, 0x7e,
 			0x04, 0x87, 0x6c, 0xd7
 		};
-	u_char expectedB[MAX_MAC_LEN] =
+	u_char expectedB[] =
 		{
 			0, 0, 0, KEYID_B,
 			0x2d, 0x4a, 0x48, 0xdd,
@@ -314,7 +314,7 @@ void test_Digest_SHA1(void);
 void test_Digest_SHA1(void)
 {
 #ifdef OPENSSL
-	u_char expectedA[MAX_MAC_LEN] =
+	u_char expectedA[] =
 		{
 			0, 0, 0, KEYID_A,
 			0xe2, 0xc6, 0x17, 0x71,
@@ -323,7 +323,7 @@ void test_Digest_SHA1(void)
 			0x79, 0x82, 0x9d, 0xcb,
 			0x2d, 0x06, 0x0e, 0xfa
 		};
-	u_char expectedB[MAX_MAC_LEN] =
+	u_char expectedB[] =
 		{
 			0, 0, 0, KEYID_B,
 			0x01, 0x16, 0x37, 0xb4,
@@ -342,32 +342,34 @@ void test_Digest_SHA1(void)
 }
 
 
-#define SHAKE128_KEYID		7
+#define SHA512_KEYID		7
 #undef KEYID_A
-#define KEYID_A			SHAKE128_KEYID
+#define KEYID_A			SHA512_KEYID
 #undef DG_SZ
-#define DG_SZ			16
+#define DG_SZ			20
 #undef KEYID_B
 #define KEYID_B			(KEYID_A + HEX_KEYID_OFFSET)
-void test_Digest_SHAKE128(void);
-void test_Digest_SHAKE128(void)
+void test_Digest_SHA512(void);
+void test_Digest_SHA512(void)
 {
 #ifdef OPENSSL
-	u_char expectedA[MAX_MAC_LEN] =
+	u_char expectedA[] =
 		{
 			0, 0, 0, KEYID_A,
-			0x5c, 0x0c, 0x1a, 0x85,
-			0xad, 0x03, 0xb2, 0x9a,
-			0xe4, 0x75, 0x37, 0x93,
-			0xaa, 0xa6, 0xcd, 0x76
+			0xd8, 0x7f, 0xac, 0xf2,
+			0x06, 0x6f, 0x96, 0x2e,
+			0x41, 0x6d, 0x6d, 0x2c,
+			0x97, 0xbe, 0x4c, 0xaf,
+			0x5f, 0x06, 0x5d, 0xa3
 		};
-	u_char expectedB[MAX_MAC_LEN] =
+	u_char expectedB[] =
 		{
 			0, 0, 0, KEYID_B,
-			0x07, 0x04, 0x63, 0xcc,
-			0x46, 0xaf, 0xca, 0x00,
-			0x7d, 0xd1, 0x5a, 0x39,
-			0xfd, 0x34, 0xca, 0x10
+			0x3f, 0x3a, 0x40, 0x33,
+			0xe5, 0x40, 0x58, 0x03,
+			0x1d, 0xbd, 0xa6, 0x98,
+			0xa2, 0x48, 0xc5, 0xdc,
+			0x79, 0xe2, 0x5c, 0x9b
 		};
 
 	TEST_ASSERT(setup);
@@ -390,7 +392,7 @@ void test_Digest_DSA(void);
 void test_Digest_DSA(void)
 {
 #ifdef OPENSSL
-	u_char expectedA[MAX_MAC_LEN] =
+	u_char expectedA[] =
 		{
 			0, 0, 0, KEYID_A,
 			0xaf, 0xa0, 0x1d, 0x0c,
@@ -399,7 +401,7 @@ void test_Digest_DSA(void)
 			0xe5, 0x28, 0x03, 0xf2,
 			0x7b, 0x5b, 0xb1, 0x4a
 		};
-	u_char expectedB[MAX_MAC_LEN] =
+	u_char expectedB[] =
 		{
 			0, 0, 0, KEYID_B,
 			0x77, 0xcd, 0x88, 0xc2,
@@ -429,7 +431,7 @@ void test_Digest_DSA_SHA(void);
 void test_Digest_DSA_SHA(void)
 {
 #ifdef OPENSSL
-	u_char expectedA[MAX_MAC_LEN] =
+	u_char expectedA[] =
 		{
 			0, 0, 0, KEYID_A,
 			0x7c, 0xb5, 0x79, 0xd0,
@@ -438,7 +440,7 @@ void test_Digest_DSA_SHA(void)
 			0x10, 0xc4, 0x59, 0x5c,
 			0xd9, 0xa4, 0x4f, 0x3b
 		};
-	u_char expectedB[MAX_MAC_LEN] =
+	u_char expectedB[] =
 		{
 			0, 0, 0, KEYID_B,
 			0xb9, 0xca, 0xa6, 0x8e,
@@ -468,7 +470,7 @@ void test_Digest_SHA(void);
 void test_Digest_SHA(void)
 {
 #ifdef OPENSSL
-	u_char expectedA[MAX_MAC_LEN] =
+	u_char expectedA[] =
 		{
 			0, 0, 0, KEYID_A,
 			0xd5, 0xbd, 0xb8, 0x55,
@@ -477,7 +479,7 @@ void test_Digest_SHA(void)
 			0xbd, 0x70, 0x0c, 0x5c,
 			0x68, 0xae, 0xb0, 0xbd
 		};
-	u_char expectedB[MAX_MAC_LEN] =
+	u_char expectedB[] =
 		{
 			0, 0, 0, KEYID_B,
 			0x63, 0x05, 0x41, 0x45,
@@ -507,7 +509,7 @@ void test_Digest_SHA256(void);
 void test_Digest_SHA256(void)
 {
 #ifdef OPENSSL
-	u_char expectedA[MAX_MAC_LEN] =
+	u_char expectedA[] =
 		{
 			0, 0, 0, KEYID_A,
 			0x3c, 0xbf, 0xff, 0xf4, 
@@ -516,7 +518,7 @@ void test_Digest_SHA256(void)
 			0xa1, 0x6b, 0x8c, 0x48, 
 			0x21, 0x0d, 0x67, 0x1a
 		};
-	u_char expectedB[MAX_MAC_LEN] =
+	u_char expectedB[] =
 		{
 			0, 0, 0, KEYID_B,
 			0x68, 0xa9, 0xd9, 0xf3, 
@@ -535,6 +537,7 @@ void test_Digest_SHA256(void)
 }
 
 
+
 /*
  * Dump a MAC in a form easy to cut and paste into the expected declaration.
  */
