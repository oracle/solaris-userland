#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#
# Copyright (c) 2010, 2025, Oracle and/or its affiliates.
#

include ../make-rules/shared-macros.mk

# For now, the assumption is we build any directory with a *.p5m file. This may
# not always be the case. If we build a new make-like tool to drive the upper
# level build, it may make different decisions and will need to include
# appropriate dependency information.

# components.mk is auto-generated by the build tools.  It populates the
# COMPONENT_DIRS macro with a list of all directories in the workspace that
# contain a component.
$(WS_MACH)/components.mk:	$(WS_MACH) # Makefile # $(WS_TOP)/components
	@echo "Generating component list..."
	@$(USERLAND_COMPONENTS) --workspace=$(WS_TOP) \
		| sed -e 's;^$(shell readlink -f "$$PWD")/;COMPONENT_DIRS += ;g' >$@

-include $(WS_MACH)/components.mk

# depends.mk is auto-generated by concatenating 'depend.mk' files in each
# component directory.
$(WS_MACH)/depends.mk:     $(WS_MACH)/components.mk
	@echo "Generating component dependencies..."
	@cat $(shell $(USERLAND_COMPONENTS) --workspace=$(WS_TOP) \
		| sed -e 's;^$(shell pwd)/;;g' -e 's;$$;/depend.mk;g') >$@ \
		2>/dev/null

-include $(WS_MACH)/depends.mk

#
# 1. Iterate over every component and print its REQUIRED_PACKAGES list.
# 2. Pipe the entire output into a helper script.
# 3. The script extracts each dependency and appends a comment that lists the
#    component(s) that require that dependency.
#
$(WS_MACH)/requires.mk:	$(WS_MACH)
	@echo "Generating list of required packages to build consolidation..."
	$(GMAKE) -j 5 --no-print-directory component-hook \
		COMPONENT_HOOK='@echo $$(REQUIRED_PACKAGES:%="%:$$(subst $$(WS_TOP)/components/,,$$(COMPONENT_DIR))\\n")'  \
		| perl $(WS_TOP)/tools/process-required-packages.pl > "$(@)"

system-check::	$(WS_MACH)/requires.mk
	@$(GMAKE) -f $(WS_MAKE_RULES)/environment.mk -f $< component-environment-check

system-prep::	$(WS_MACH)/requires.mk
	@echo "Installing any missing packages..."
	@$(GMAKE) -f $(WS_MAKE_RULES)/environment.mk -f $< component-environment-prep

download:		TARGET = download
unpack:			TARGET = unpack
patch:			TARGET = patch
prep:			TARGET = prep
build:			TARGET = build
install:		TARGET = install
mangle:			TARGET = mangle
publish:		TARGET = publish
clean:			TARGET = clean
clobber:		TARGET = clobber
test:			TARGET = test
system-test:		TARGET = system-test
check_anitya:		TARGET = check_anitya
check_rtime:		TARGET = check_rtime
zone-build:		TARGET = component-zone-build
component-hook:		TARGET = component-hook
regen-patches:		TARGET = regen-patches
download zone-build prep build install mangle publish test system-test check_rtime regen-patches:	\
	LOG = >$(WS_LOGS)/$(subst /,.,$@).$(TARGET).log 2>&1 ; \
	RET=$$? ; \
	if [ -d $(WS_COMPONENTS)/$@/build ]; then \
	$(RM) $(WS_COMPONENTS)/$@/build/$(TARGET).$(MACH).log ; \
	$(LN) -s $(WS_LOGS)/$(subst /,.,$@).$(TARGET).log $(WS_COMPONENTS)/$@/build/$(TARGET).$(MACH).log ; \
	fi ; \
	exit $$RET

# turn off pkglint for the individual component builds.
ifeq   ($(strip $(PKGLINT_COMPONENT)),)
publish:		MAKEFLAGS += PKGLINTVAR=/bin/true
endif

# In order to work around an IPS simultaneous publication issue and to improve
# top level build performance, we postpone catalog and index updates until the
# end of the build.  Individual component builds postpone the updates until
# they have published all of their packages.
publish:		MAKEFLAGS += DISABLE_IPS_CATALOG_AND_INDEX_UPDATES=yes

# For cases in which a component test should be skipped at at the top level
test:			MAKEFLAGS += TOP_LEVEL_TEST=yes
system-test:		MAKEFLAGS += TOP_LEVEL_TEST=yes

# We need to distinguish between the full and one component build
# in order to tune the number of parallel build jobs.
build install mangle publish:	MAKEFLAGS += TOP_LEVEL_RUN=yes

.DEFAULT_GOAL :=	publish

zone-build build install mangle publish test system-test: $(COMPONENT_DIRS)

COMPONENT_DIRS.nosetup =	$(COMPONENT_DIRS:%=%.nosetup)

download unpack patch::	$(COMPONENT_DIRS.nosetup)
prep check_anitya check_rtime regen-patches:	$(COMPONENT_DIRS.nosetup)
component-environment-check::	$(COMPONENT_DIRS.nosetup)
component-hook:	$(COMPONENT_DIRS.nosetup)

clean:		$(COMPONENT_DIRS.nosetup)
	$(RM) $(WS_MACH)/components.mk $(WS_MACH)/depends.mk \
	      $(WS_MACH)/requires.mk $(WS_MACH)/*.p5m

clobber:	$(COMPONENT_DIRS.nosetup) clean
	@cd ../tools ; echo "clobbering tools..." ; $(GMAKE) clobber
	$(RM) -r $(WS_REPO) $(WS_EXPERIMENTAL_REPO) $(WS_HOME) $(WS_LOGS) $(WS_LINT_CACHE)

setup:	$(WS_MACH) $(WS_LOGS) $(WS_HOME) $(WS_REPO) $(WS_EXPERIMENTAL_REPO) tools $(WS_LINT_CACHE) $(WS_TOP)/.hgignore

$(WS_MACH) $(WS_LOGS) $(WS_HOME):
	$(MKDIR) $@

$(WS_REPO):
	$(PKGREPO) create $(PKG_REPO)
	$(PKGREPO) add-publisher -s $(PKG_REPO) $(PUBLISHER)
	$(PKGREPO) add-publisher -s $(PKG_REPO) $(PUBLISHER_LOCALIZABLE)

$(WS_EXPERIMENTAL_REPO):
	$(PKGREPO) create $(PKG_EXPERIMENTAL_REPO)
	$(PKGREPO) add-publisher -s $(PKG_EXPERIMENTAL_REPO) $(PUBLISHER)
	$(PKGREPO) add-publisher -s $(PKG_EXPERIMENTAL_REPO) $(PUBLISHER_LOCALIZABLE)

DUMMYPKG =  "set name=fmri value=pkg:/dummy@0,$(BUILD_VERSION)\n"
DUMMYPKG += "set pkg.summary=dummy\n"
DUMMYPKG += "set org.opensolaris.consolidation=userland\n"
DUMMYPKG += "set info.classification=org.opensolaris.category.2008:System/Core"

$(WS_LINT_CACHE):	$(WS_LOGS) tools
ifdef CANONICAL_REPO
	@echo "Generating pkglint(1) cache from CANONICAL_REPO $(CANONICAL_REPO)..."
	@(echo $(DUMMYPKG) | time $(PKGLINTVAR) \
		-c $(WS_LINT_CACHE) -r $(CANONICAL_REPO) /dev/fd/0 \
		>$(WS_LOGS)/naughty-canonical-repo-actions 2>&1; \
		RET=$$?; \
		echo "TARGET_EXIT_CODE $$RET" >>$(WS_LOGS)/naughty-canonical-repo-actions 2>&1; \
		[ $$RET -eq 0 ] || echo "pkglint(1) failed, please see $(WS_LOGS)/naughty-canonical-repo-actions"; \
		exit $$RET \
	)
else
	$(MKDIR) $(WS_LINT_CACHE)
endif

tools:
	@echo "building tools..."
	+$(GMAKE) -C ../tools clean
	+$(GMAKE) -C ../tools setup

$(WS_TOP)/.hgignore: $(WS_TOP)/.hgignore.template
	$(CP) $(WS_TOP)/.hgignore.template $(WS_TOP)/.hgignore

# The default number of build jobs per component if the full workspace is built.
# 1 disables parallel build in component, 0 lets the system autodetect number
# of parallel jobs
$(call read-config,JOBS_PER_COMPONENT,1)

$(COMPONENT_DIRS):	$(WS_LOGS) setup FORCE
	@cd $@ && echo "$(TARGET) $@" && \
	( env MAKELEVEL= COMPONENT_MAKE_JOBS=$(JOBS_PER_COMPONENT) \
		time $(COMPONENT_MAKE_WRAPPER) $(GMAKE) --jobs=1 --no-keep-going $(TARGET); \
		RET=$$?; \
		echo TARGET_EXIT_CODE $$RET; \
		exit $$RET \
	) $(LOG)

# Turn userland-incorporator warnings into build failures
INCORPORATE_WERROR ?= --Werror

# The incorporation target publishes some packages. Because of that it needs to
# have PUBLISH_LOG set so that the created packages are noted somewhere by the
# GNU Make function log-package-publish
incorporation: PUBLISH_LOG=$(WS_TOOLS)/incorporator
# rm of smcc-incorporation.p5m is a temporary hack to avoid unnecessary
# republishing of it until Userland starts pkgsurf'ing its deliveries.
incorporation:
	@echo 'Creating incorporations'
	@( \
		set -x; \
		$(WS_TOOLS)/userland-incorporator \
			--repository $(PKG_REPO) \
			--version $(PKG_SOLARIS_VERSION),$(BUILD_VERSION) \
			--incorporation-version runtime/python-37-incorporation=99,$(BUILD_VERSION) \
			--publisher $(PUBLISHER) \
			--destdir $(WS_MACH) \
			--repository-changeset $(CONSOLIDATION_CHANGESET) \
			--repository-url $(CONSOLIDATION_REPOSITORY_URL) \
			--static-content-file $(WS_COMPONENTS)/meta-packages/incorporation-cache \
			$(INCORPORATE_WERROR) && \
		$(RM) $(WS_MACH)/smcc-incorporation.p5m && \
		for incorporation in $(WS_MACH)/*.p5m ; do \
		    $(call log-package-publish, $${incorporation}) ; \
		    $(PKGSEND) -s $(PKG_REPO) publish --fmri-in-manifest \
			       $${incorporation} || exit $$?; \
		done \
	) >$(WS_LOGS)/incorporator 2>&1; \
	RET=$$?; \
	echo "TARGET_EXIT_CODE $$RET" >>$(WS_LOGS)/incorporator; \
	[ $$RET -eq 0 ] || echo "Incorporator failed, please see $(WS_LOGS)/incorporator"; \
	exit $$RET

# Use PKGLINT below instead of PKGLINTVAR because we know we always want the
# real one for this set of rules.  We use $(wildcard ...) because not all
# component directories might get published
pkglint:
	@echo 'pkglinting all package manifests...'
	@$(ENV) SOLARIS_VERSION=$(SOLARIS_VERSION) \
			$(PKGLINT) -e $(WS_TOOLS)/python/ \
			-c $(WS_LINT_CACHE) -f $(WS_TOOLS)/pkglintrc \
			$(wildcard $(COMPONENT_DIRS:%=%/build/manifest-*.published)) \
			>$(WS_LOGS)/pkglint 2>&1; \
	RET=$$?; \
	echo "TARGET_EXIT_CODE $$RET" >>$(WS_LOGS)/pkglint; \
	[ $$RET -eq 0 ] || echo "Pkglint failed, please see $(WS_LOGS)/pkglint"; \
	exit $$RET

publish:
	$(PKGREPO) refresh -s $(PKG_REPO)
	$(PKGREPO) refresh -s $(PKG_EXPERIMENTAL_REPO)
ifndef SKIP_BUILDING_INCORPORATIONS
	$(MAKE) incorporation
endif
# pkglint all of the published manifests in one batch.
ifdef CANONICAL_REPO
	$(MAKE) pkglint
endif

$(COMPONENT_DIRS.nosetup):	$(WS_LOGS) FORCE
	@cd $(@:%.nosetup=%) && echo "$(TARGET) $(@:%.nosetup=%)" && \
	 env COMPONENT_MAKE_JOBS=$(JOBS_PER_COMPONENT) \
	 $(GMAKE) $(TARGET) $(LOG)

# component report uses component-hook to process every component.
# component-hook however executes on the 'components' directory itself (it's
# defined in shared-macros.mk). We don't want to run component report in this
# directory, thus we need to disable it
NO_PKG_REPORT = 1

FORCE:
