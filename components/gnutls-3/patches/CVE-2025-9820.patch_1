Modified patch from
https://gitlab.com/gnutls/gnutls/-/commit/1d56f96f6ab5034d677136b9d50b5a75dff0faf5

The new tests are stripped as they would not apply cleanly to 3.8.10

The patch can be removed with update to 3.8.11 or later

From 1d56f96f6ab5034d677136b9d50b5a75dff0faf5 Mon Sep 17 00:00:00 2001
From: Daiki Ueno <ueno@gnu.org>
Date: Tue, 18 Nov 2025 13:17:55 +0900
Subject: [PATCH] pkcs11: avoid stack overwrite when initializing a token

If gnutls_pkcs11_token_init is called with label longer than 32
characters, the internal storage used to blank-fill it would
overflow. This adds a guard to prevent that.

--- gnutls-3.7.1/lib/pkcs11_write.c
+++ gnutls-3.7.1/lib/pkcs11_write.c
@@ -28,6 +28,7 @@ #include <pkcs11_int.h>
 #include "pkcs11x.h"
 #include <x509/common.h>
 #include "pk.h"
+#include "minmax.h"
 
 static const ck_bool_t tval = 1;
 static const ck_bool_t fval = 0;
@@ -1199,7 +1200,7 @@ /**
  * gnutls_pkcs11_token_init:
  * @token_url: A PKCS #11 URL specifying a token
  * @so_pin: Security Officer's PIN
- * @label: A name to be used for the token
+ * @label: A name to be used for the token, at most 32 characters
  *
  * This function will initialize (format) a token. If the token is
  * at a factory defaults state the security officer's PIN given will be
@@ -1238,7 +1239,7 @@ }
 	/* so it seems memset has other uses than zeroing! */
 	memset(flabel, ' ', sizeof(flabel));
 	if (label != NULL)
-		memcpy(flabel, label, strlen(label));
+		memcpy(flabel, label, MIN(sizeof(flabel), strlen(label)));
 
 	rv = pkcs11_init_token(module, slot, (uint8_t *) so_pin,
 			       strlen(so_pin), (uint8_t *) flabel);
